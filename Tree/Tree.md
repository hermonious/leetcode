

1. 最需要重视的是二叉树。顾名思义，在二叉树中每个节点最多只有两个子节点，可以分别把它们称为左子节点和右子节点。
2. 二叉树的根节点没有父节点，一棵非空二叉树只有一个父节点。
3. 二叉树的叶节点没有子节点
4. 二叉树的每个节点的度最多为2
5. 二叉树的第i层上的节点最多为2^(i-1)个
6. 高度为h的二叉树最多有2^h-1个节点


二叉树是典型的具有 ‘递归’ 性质的数据结构
二叉树的深度优先搜索分为：前序遍历、中序遍历、后序遍历



与二叉树中路径相关的面试题有很多，通常这些面试题都可以用 ‘dfs’ 解决，很少采用 ‘bfs’    
这是因为路径通常顺着指向子节点的指针的方向（纵向），这更加符合 ‘dfs’ 的特点。‘bfs’是从左到右遍历每层的节点（横向）  

    ‘bfs’ 更适合解决与 ’层‘ 相关的题，
    ‘dfs’ 更加适合解决与 ’路径‘ 相关的题



BST是一类特殊的二叉树，它的左子节点总是小于或等于根节点，而右子节点总是大于或等于根节点。在BST中进行 '搜索、添加、删除' 操作的平均时间复杂度都是 O(logn)。如果按照 ’中序遍历‘ 的顺序遍历一棵二叉搜索树，就会按照 ’从小到大‘ 的顺序依次遍历每个节点。由于这个特性，与二叉搜索树相关的很多面试题都适合使用中序遍历解决。




    
    如果面试题的数据集合是动态的（即题目要求逐步在数据集合中添加更多的数据），并且需要根据数据的大小实现快速查找，那么可能需要用到TreeSet 或 TreeMap
    
    哈希表只能根据 ‘键’ 进行查找，只能判断该键是否存在。如果需要根据数值的大小查找，如查找数据集合中比某个值大的所有数字中的最小的一个，哈希表就无能为力。
    
    如果在一个排序的动态数组（如 Java 的 ArrayList）中根据数值的大小进行查找，则可以应用二分查找算法实现时间效率为 O(logn)的查找。但排序的动态数组的添加和删除操作的时间复杂度是 O(n)。 
    
    由于 TreeSet 或 TreeMap 能够保证其内部的二叉搜索树是平衡的，因此它们的查找、添加和删除操作的时间复杂度都是 O(logn)，综合来看它们比动态排序数组更加高效。 

    实现一棵平衡的二叉搜索树对于面试来说不是一件容易的事情。Java 根据红黑树这种平衡的二叉搜索树实现 TreeSet 和 TreeMap 两种数据结构

TreeSet 实现了接口 Set，它内部的平衡二叉树中的每个节点只包含一个值
除了Set的常用函数，TreeSet还有以下常用函数：
    
    ceiling    
    floor      
    higher    
    lower      


TreeMap 内部的平衡二叉搜索树中的每个节点都是一个包含键值和值的映射
除了Map的常用函数，TreeMap还有以下常用函数：
    
    ceilingEntry     
    floorEntry       
    higherEntry      
    lowerEntry     
