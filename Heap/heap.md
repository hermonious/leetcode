

堆是一种特殊的树状数据结构，它满足以下性质：

    1. 堆是一个完全二叉树，即除了最后一层，其他层的节点都是满的，最后一层的节点都靠左排列。
    2. 堆中的每个节点的值都大于或等于（最大堆）或小于或等于（最小堆）其任意子节点的值。



    在最大堆中，每个节点的值总是大于或等于其任意子节点的值，因此最大堆的根节点就是整个堆的最大值。在最小堆中，每个节点的值总是小于或等于其任意子节点的值，因此最小堆的根节点就是整个堆的最小值。



    堆通常用于实现优先队列，因为它可以在 O(log n) 的时间复杂度内插入、删除、获取最大值（或最小值）。


堆的实现

    如果用数组表示堆，那么数组中的每个元素对应堆的一个节点。
    如果数组中的一个元素的下标为 i，那么它在堆中对应节点的父节点在数组中的下标为(i-1)/2，
    而它的左、右子节点在数组中的下标分别为 2i+1 和 2i+2



添加新节点的过程如下：

    1. 将新节点添加到数组的末尾。
    2. 从新节点开始，自下而上地比较它与父节点的大小关系。
    3. 如果新节点大于（或小于）父节点，交换它们的位置。
    4. 重复步骤 2 和 3，直到新节点小于（或大于）父节点，或者到达根节点。


删除节点的过程如下：

    1. 将要删除的节点与数组的最后一个节点交换位置。
    2. 删除数组的最后一个节点。
    3. 从要删除的节点开始，自上而下地比较它与子节点的大小关系。
    4. 如果要删除的节点小于（或大于）子节点，交换它们的位置。
    5. 重复步骤 3 和 4，直到要删除的节点大于（或小于）子节点，或者到达叶子节点。


获取节点的过程如下：

    1. 要获取的节点的下标为 i，那么它在数组中的位置为 i。
    2. 返回该位置的元素即可。





    Java 提供了类型 PriorityQueue 实现数据结构堆
    PriorityQueue 在默认情况下是一个 “最小堆”，如果使用最大堆调用构造函数就需要传入 Comparator 改变比较排序的规则
    PriorityQueue 实现了接口 Queue
    PriorityQueue 的删除顺序与元素添加的顺序无关
    常用方法：
        抛出异常        不抛出异常
        add(e)         offer(e)
        remove()       poll()
        element()      peek()


    堆经常用来解决在数据集合中找出 k 个最大值或最小值相关的问题。通常用最大堆找出数据集合中的 k 个最小值，用最小堆找出数据集合中的 k 个最大值。

    Java 的库中提供了类型 PriorityQueue，虽然该类型实现了接口 Queue，但它是堆而不是队列。
    PriorityQueue 的构造函数能 ‘传入不同的比较规则’ ，从而创建最大堆或最小堆。






PriorityQueue 实现原理

    底层结构：基于二叉堆（Binary Heap） 实现，默认为最小堆（堆顶元素最小）；实际存储使用 Object[] 数组，通过父子节点索引关系隐式维护树形结构。
    堆的性质：
    任意节点的值不大于（最小堆）或不小于（最大堆）其子节点；
    堆是一棵完全二叉树，因此可用数组紧凑存储，无指针开销。
    
    排序依据：
    默认按元素自然顺序（要求实现 Comparable）；
    也可通过构造时传入 Comparator 自定义优先级。

    核心操作时间复杂度：
    入队（offer / add）：O(log n) —— 元素插入末尾后“上浮”调整堆；
    出队（poll / remove）：O(log n) —— 移除堆顶后，末尾元素移至顶部并“下沉”调整；
    查看堆顶（peek / element）：O(1) —— 直接访问数组首元素。
    不支持 null 元素：因为无法与堆中其他元素比较。

    非线程安全：多线程并发操作可能导致堆结构破坏。
    不保证遍历顺序：迭代器（iterator()）不按优先级顺序返回元素，仅用于遍历所有元素。

    扩容机制：初始容量通常为 11；当元素数量超过当前容量时，自动扩容（类似 ArrayList，但策略略有不同）。

    适用场景：需要动态获取最值的场景，如任务调度、Top-K 问题、Dijkstra 算法、合并多个有序流等。

    与 TreeSet 对比：
    PriorityQueue 只能高效访问堆顶，不能快速查找或删除任意元素；
    TreeSet 支持有序遍历和任意元素删除（O(log n)），但内存开销更大。

