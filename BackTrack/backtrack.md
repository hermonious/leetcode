
1. 一个问题多个步骤，每个步骤多个选项
# 回溯法可以看作蛮力法的升级版，它在解决问题时的每一步都尝试所有可能的选项，最终找出所有可行的解决方案。回溯法非常适合解决由 '多个步骤' 组成的问题，并且每个步骤都有 '多个选项' 。在某一步选择了其中一个选项之后，就进入下一步，然后会面临新的选项。就这样重复选择，直至到达最终的状态




2. 抽象成 ‘树’
# 用回溯法解决问题的过程可以形象地用一个树形结构表示，求解问题的每个步骤可以看作树中的一个节点。如果在某一步有 n 个可能的选项，每个选项是树中的一条边，经过这些边就可以到达该节点的 n 个子节点


3. 剪枝优化
# 由于回溯法是在所有选项形成的树上进行 DFS，如果解决问题的步骤较多或每个步骤都面临多个选项，那么遍历整棵树将需要较多的时间。如果明确知道某些子树没有必要遍历，那么在遍历的时候应该避开这些子树以优化效率。通常将使用回溯法时避免遍历不必要的子树的方法称为剪枝





应用回溯法能够解决集合的排列、组合的很多问题。仔细分析这些问题及其变种的代码就会发现最终的代码大同小异，都可以采用递归的代码实现。递归代码需要先确定递归退出的边界条件，然后逐个处理集合中的元素。

1. 对于组合类问题，每个数字都面临 2 个选项，即添加 / 不添加当前数字到组合中

2. 对于排列类问题，一个数字如果后面有 n 个数字，那么面临 n+1 个选择，即可以将该数字和它后面的数字（也包括它自身）交换。根据这些选项做出选择之后再调用递归函数处理后面的数字。 
