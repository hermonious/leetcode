


1. 物体对应图中的节点，如果两个物体存在某种关系，那么它们在图中对应的节点有一条边相连
2. 图分为有向图和无向图，有向图的边是单向的，无向图的边没有方向
3. 图分为有权图和无权图，有权图的边有权重，无权图的边没有权重


图可以使用 领接表 / 邻接矩阵 来表示
领接表（适合稀疏图——图中的节点数目非常大，但是每个节点的邻居节点数目比较少）
    
    它使用一个数组来存储图中的节点，每个节点对应一个链表，链表中存储了该节点的所有邻居节点
邻接矩阵（适合稠密图——图中的节点数目比较多，每个节点的邻居节点数目也比较多）
    
    它使用一个二维数组来存储图中的节点，数组中的 0 / 1 表示两个节点之间是否有边相连
    0 表示没有边相连，1 表示有边相连



找出一条从起始节点到目标节点的路径或遍历所有节点，是与图相关的最重要的算法。按照搜索顺序不同可以将搜索算法分为 BFS（队列） 和 DFS


1. BFS——无权图里面，两个节点之间的最短路径
2. DFS保证从起始节点到目标节点的路径中，直观展示所经过的所有节点



注意：

    1. 当沿着图中的边搜索一个图时，一定要确保程序不会因为沿着环的边不断在环中搜索而陷入死循环
    2. 避免死循环的办法是：
    记录已经搜索过的节点，在访问一个节点之前先判断该节点之前是否已经访问过，如果之前访问过那么这次就略过不再重复访问
    3. 最简单的办法是使用一个数组来记录，数组中的每个元素对应图中的一个节点，数组中的元素值为 true 表示该节点已经访问过，为 false 表示该节点没有访问过
    4. 记录已经搜索过的节点的数组可以在搜索开始之前就创建好，也可以在搜索过程中动态创建
        4.1 动态创建的办法是在访问一个节点之前，先判断该节点之前是否已经访问过，如果之前没有访问过，那么就创建一个新的元素并将其值设置为 true，否则就直接略过不再重复访问
        4.2 动态创建的数组可以使用 ArrayList / LinkedList 等数据结构来实现











1、拓扑排序
   
    拓扑排序是指对一个有向无环图的节点进行排序之后得到的序列。如果存在一条从节点 A 指向节点 B 的边，那么在拓扑排序的序列中节点 A 出现在节点 B 的前面。一个有向无环图可以有一个或多个拓扑排序序列，但无向图或有环的有向图都不存在拓扑排序。 
    拓扑排序可以解决与任务顺序相关的问题。如果某些任务必须在其他任务之前（或之后）完成，则可以用一个有向图描述任务之间的依赖关系，然后通过拓扑排序得到所有任务的执行顺序



2、并查集

    如果一个问题对应的图可以分成若干子图，并且需要判断两个节点是否在同一个子图中且在某些时候合并两个子图，那么可以考虑采用并查集来解决这个问题。并查集用一个树形结构表示集合中的一个子集，每个子集对应图中的一个子图
