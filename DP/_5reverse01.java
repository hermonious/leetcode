
// 输入一个只包含'0'和'1'的字符串，其中，'0'可以翻转成'1'，'1'可以翻转成'0'
// 请问至少需要翻转几个字符，才可以使翻转之后的字符串中所有的'0'位于'1'的前面？翻转之后的字符串可能只包含字符'0'或'1'
// 输入字符串"00110"，至少需要翻转一个字符才能使所有的'0'位于'1'的前面：可以将最后一个字符'0'翻转成'1'，得到字符串"00111"



// f(i)是把字符串从下标为 0 的字符到下标为 i 的字符，变成符合要求的字符串，并且最后一位是'0'的最少翻转次数
// g(i)是把字符串从下标为 0 的字符到下标为 i 的字符，变成符合要求的字符串，并且最后一位是'1'的最少翻转次数
// 把下标从 0 到 i的字符记为 S[0....i]

// 那么，S[i] = '0'时
    // f(i) = f(i-1)
    // g(i) = min(g(i-1), f(i-1)) + 1

// 那么，S[i] = '1'时
    // f(i) = f(i-1) + 1
    // g(i) = min(f(i-1), g(i-1))

// s[0] = '0'时
// f(0) = 0
// g(0) = 1

// s[0] = '1'时
// f(0) = 1
// g(0) = 0


public class _5reverse01 {
    public int reverse(String s) {

        int len = s.length();
        if (len == 0) {
            return 0;
        }

        int[][] dp = new int[2][2];
        char ch = s.charAt(0);
        dp[0][0] = ch == '0' ? 0 : 1;
        dp[1][0] = ch == '1' ? 0 : 1;

        for (int i = 1; i < len; i++) {
            ch = s.charAt(i);
            int prev1 = dp[0][(i - 1) % 2];
            int prev2 = dp[1][(i - 1) % 2];

            dp[0][i % 2] = prev1 + (ch == '0' ? 0 : 1);
            dp[1][i % 2] = Math.min(prev1, prev2) + (ch == '1' ? 0 : 1);
        }
        return Math.min(dp[0][(len - 1) % 2], dp[1][(len - 1) % 2]);
    }


        

}
