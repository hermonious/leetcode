运用动态规划解决问题:
1. 求一个问题的 ‘最优解’ （通常是求最大值或最小值）
2. 求问题的解的 ‘数目’ （或判断问题是否存在解）

经典题目
1. 爬楼梯的最小成本
2. 打家劫舍
3. 数字之和等于目标值的所有排列的数目
4. 背包问题

# 根据题目推导出——状态状态转移方程（递归表达式）
通常，直接用递归的代码实现状态转移方程存在大量的重复计算，因此需要将计算结果进行缓存，以确保每个值只计算一次

递归的代码按照 '自上而下' 的顺序解决问题
迭代的代码按照 '自下而上' 的顺序解决问题。
迭代的代码可以更好地控制计算的顺序，可能会减少缓存所需要的空间复杂度，进一步优化空间效率






1. 动态规划的理解

   假设我身上带了足够的1、5、10、20、50、100元面值的钞票。现在目标是凑出 '某个金额 AMOUNT'，并使用尽量少的钞票

   依据生活经验，显然可以采取这样的策略：能用100的就尽量用100的，否则尽量用50的……依次类推。在这种策略下：666=6×100+1×50+1×10+1×5+1×1，共使用了10张钞票。

   这就是“贪心”策略——假设我们是“需要凑出 AMOUNT ”，贪心策略会尽快让 'AMOUNT' 变得更小。能让 'AMOUNT' 少100就尽量让它少100，这样我们接下来面对的局面就是凑出 'AMOUNT - 100' ，长期的生活经验表明，贪心策略是正确的。

   但是如果我们换一组钞票的面值，贪心策略就也许不成立了。如果一个奇葩国家的钞票面额分别是1、5、11，那么我们在凑出15的时候，贪心策略会出错：　　     15=1×11+4×1    （贪心策略使用了5张钞票）
    15=3×5         （正确的策略，只用3张钞票）

   为什么会这样呢？贪心策略错在了哪里？——鼠目寸光。

   贪心策略是：“尽量使接下来处理的 'AMOUNT' 更小”。所以贪心策略在 'AMOUNT' = 15的局面时，会优先使用11来把 'AMOUNT' 降到4；但是在这个问题中，凑出4的代价是很高的---------必须使用4×1。如果使用了5，w会降为10，虽然没有4那么小，但是凑出10只需要两张5元。

   在这里我们发现，贪心是一种只考虑眼前情况的策略。那么，现在我们怎样才能避免鼠目寸光呢？如果直接暴力枚举，明显复杂度过高，时间是不可承受的。现在来尝试找一下有什么规律

   重新分析刚刚的例子，'AMOUNT' = 15时
   如果取11，接下来就面对'AMOUNT' = 4的情况；
   如果取5，则接下来面对'AMOUNT' = 10的情况

   这些问题都有相同的形式：“给定AMOUNT，凑出 'AMOUNT' 所用的最少钞票是多少张？”接下来，使用f(a)————————“凑出 'AMOUNT' 所需的最少钞票数量”

   那么，如果使用11来凑出15，最后的代价（用掉的钞票总数）是多少呢？
   cost = f(4) + 1 = 4 + 1 = 5
   意义是：利用11来凑出15，付出的代价等于f(4)加上自己这一张钞票。现在我们暂时不管f(4)怎么求出来

   同理，如果使用5来凑出15
   cost = f(10) + 1 = 2 + 1 = 3

   所以 w = 15时，应该取cost值最小的那一个
   取11——cost = 5
   取5——cost = 3
   取1——cost = f(14) + 1 = 4 + 1 = 5


   明显cost值最低的是取5的方案。我们通过上面三个式子，做出了正确的决策！

   更给了一个至关重要的启示——f(a) = min{f(a-11), f(a-5), f(a-1)} + 1

   也就是说：要求出f(a)，只需要求出几个更小的f(a)的值；既然如此，我们从小到大把所有的f(a)求出来不就好了？注意一下边界情况即可

    public static void main(String[] args) {
    Scanner sc = new Scanner(System.in);
    int n = sc.nextInt();

    // 初始化数组，INF 表示无穷大
    final int INF = Integer.MAX_VALUE;
    int[] f = new int[105];
    for (int i = 0; i < 105; i++) {
        f[i] = INF;
    }
    f[0] = 0; // 起点

    for (int i = 1; i < n; i++) {
        int cost = INF;
        if (i - 1 >= 0) cost = Math.min(cost, f[i - 1] + 1);
        if (i - 5 >= 0) cost = Math.min(cost, f[i - 5] + 1);
        if (i - 11 >= 0) cost = Math.min(cost, f[i - 11] + 1);
        f[i] = cost;

   System.out.printf("f[%d]=%d\n", i, f[i]);
    }
    sc.close();
}


   1、f(a)只和 f(a-11), f(a-5), f(a-1)有关
   2、我们只关心 f(a) 的值，怎么凑出 'AMOUNT' 的过程根本不重要。

   这两个事实，保证了我们做法的正确性。它比起贪心策略，会分别算出取1、5、11的代价，从而做出一个正确决策，这样就避免掉了“鼠目寸光”

   它与暴力的区别在哪里？我们的暴力枚举了“使用的硬币”，但是这些都属于冗余信息
   
   我们要的是答案，根本不关心这个答案是怎么凑出来的。譬如，要求出f(15)，只需要知道f(14),f(10),f(4)的值，其他信息根本不重要

   所以必须舍弃冗余信息。只记录了对解决问题有帮助的信息——f(a)。能这样做是因为问题的性质：为了求出最终的f(a)，只需要知道几个更小的f(b)。我们将求解f(b)称作求解f(a)的“子问题”

   DP（dynamic programming）------将一个问题拆成几个子问题，分别求解这些子问题，即可推断出大问题的解





1. 无后效性------就是指一旦f(a)确定，“我们如何凑出f(a)”就再也用不着了
   比如：要求出f(15)，只需要知道f(14),f(10),f(4)的值，而f(14),f(10),f(4)是如何算出来的，对之后的问题没有影响
   “未来与过去无关”，这就是无后效性。　　（严格定义：如果给定某一阶段的状态，则在这一阶段以后过程的发展不受这阶段以前各段状态的影响）

2. 最优子结构-----回顾我们对f(a)的定义：记“凑出 'AMOUNT' 所需的最少钞票数量”为f(a).
   f(a)的定义就已经蕴含了“最优”，利用 'AMOUNT' = 14,10,4的最优解，即可算出 'AMOUNT' = 15的最优解
   大问题的最优解可以由小问题的最优解推出，这个性质叫做“最优子结构”



   引入这两个概念之后，我们如何判断一个问题能否使用DP解决呢？--------能将大问题拆成几个小问题，且满足无后效性、最优子结构



   DP为什么会快？无论是DP还是暴力，我们的算法都是在可能解空间内，寻找最优解

   来看钞票问题。暴力做法是枚举所有的可能解，这是最大的可能解空间。
   DP是枚举有希望成为答案的解。这个空间比暴力的小得多。
   也就是说：DP自带剪枝。DP舍弃了一大堆不可能成为最优解的答案。譬如：　　15 = 5+5+5 被考虑了。　　15 = 5+5+1+1+1+1+1 从来没有考虑过，因为这不可能成为最优解。　　从而我们可以得到DP的核心思想：尽量缩小可能解空间。
   在暴力算法中，可能解空间往往是指数级的大小；如果我们采用DP，那么有可能把解空间的大小降到多项式级。　　一般来说，解空间越小，寻找解就越快。这样就完成了优化。




   下面介绍比较通用的设计DP算法的步骤。
   首先，把我们面对的局面表示为x，这一步称为设计状态。

   对于状态x，记我们要求出的答案为f(x)，我们的目标是求出f(T)，找出f(x)与哪些局面有关（记为p），写出一个式子（称为状态转移方程），通过f(p)来推出f(x)

   设计DP算法：
       我是谁？  ——设计状态，表示局面
       我从哪里来？
       我要到哪里去？  ——设计转移
   设计状态是DP的基础。接下来的设计转移有两种方式：一种是考虑我从哪里来（pull）；另一种是考虑我到哪里去，这常见于求出f(x)之后，更新能从x走到的一些解（push）
   
   总而言之，“我从哪里来”和“我要到哪里去”只需要考虑清楚其中一个，就能设计出状态转移方程，从而写代码求解问题。

   pull型的转移-------要求出f(n)，就要从f(n-1)推导           适用于大多数背包问题、序列DP
   push型的转移-------知道了f(n-1)，就可以推导出f(n)         适用于图DP、状态转移图、某些最短路问题





经典例题：最长递增子序列（LIS）
    给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。
    子序列 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列


思路：设 dp[i] 表示 以 nums[i] 结尾的最长严格递增子序列的长度（    必须是以 nums[i] 结尾    ）

初始条件------dp[i] = 1，因为每个元素自身构成一个长度为 1 的递增子序列

对于每个 i（从 0 到 n-1），我们检查所有 j < i：
    如果 nums[j] < nums[i]，说明可以把 nums[i] 接在以 nums[j] 结尾的递增子序列后面，形成更长的递增子序列。此时有：dp[i] = max(dp[i], dp[j] + 1)
    如果不存在这样的 j（即前面没有比 nums[i] 小的数），则 dp[i] = 1（只包含自己）


代码实现：
public int lengthOfLIS(int[] nums) {
int n = nums.length;
if (n == 0) return 0;

int[] dp = new int[n];
Arrays.fill(dp, 1); // 初始值为 1

int res = 1;
for (int i = 1; i < n; i++) {
    for (int j = 0; j < i; j++) {
        if (nums[j] < nums[i]) {
            dp[i] = Math.max(dp[i], dp[j] + 1);
        }
    }
    res = Math.max(res, dp[i]);
}
return res;
}






   


